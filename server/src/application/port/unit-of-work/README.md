# Unit of Work - トランザクション管理

複数のリポジトリ操作を1つのトランザクションとして管理するパターン。データの一貫性を保証し、ACID特性を実現。

## 責務

- **トランザクション境界の管理**: 開始・コミット・ロールバック
- **操作の登録**: 複数のデータベース操作をまとめる
- **自動コミット**: 成功時の自動コミット
- **自動ロールバック**: エラー時の自動ロールバック

## ファイル構成

```
unit-of-work/
├── index.ts                        # エクスポート定義
├── unit-of-work.ts                 # UnitOfWorkインターフェース
├── unit-of-work-runner.ts          # UnitOfWorkRunnerインターフェース
└── unit-of-work-runner.dummy.ts    # テスト用Dummy実装
```

## インターフェース定義

### TransactionOperation

トランザクション操作の型。

**型定義:**

- `unknown` - 具体的な型はインフラ層で定義
- 永続化技術によって異なる型になる
- インターフェースは実装に依存しない

### UnitOfWork

トランザクション内で実行する操作を登録・管理するインターフェース。

**メソッド:**

1. `registerOperation(operation: TransactionOperation): void`

   - トランザクション操作を追加
   - リポジトリから呼び出される
   - 内部配列に操作を蓄積

2. `getOperationCount(): number`
   - 登録された操作の数を取得
   - デバッグやテストで使用

**特徴:**

- 操作を登録するだけでコミットはしない
- 複数の操作をバッチで実行
- トランザクション制約のチェック（最大件数等）

### UnitOfWorkRunner

トランザクション境界を管理し、コールバック内でトランザクション操作を実行するインターフェース。

**型パラメータ:**

- `TUoW` - Unit of Work内で使用可能なリソース（リポジトリなど）の型

**メソッド:**

1. `run<TResult>(callback: (uow: TUoW) => Promise<TResult>): Promise<TResult>`
   - トランザクション内でコールバックを実行
   - コールバック成功時は自動コミット
   - エラー発生時は自動ロールバック
   - コールバックの戻り値を返す

**責務:**

- トランザクションの開始
- Unit of Workインスタンスの生成
- リポジトリコンテキストの作成
- コミット/ロールバックの自動実行

## 実装

### インフラ層での実装

実装は `infrastructure/unit-of-work/` に配置。詳細は `../../../infrastructure/unit-of-work/README.md` を参照。

**実装の責務:**

- トランザクション操作の管理
- コミット/ロールバックの実行
- 永続化技術固有の制約チェック
- エラーハンドリング

### テスト用Dummy実装

`unit-of-work-runner.dummy.ts` でモック実装を提供。スモールテストで使用。

**特徴:**

- トランザクション処理を実行しない
- コールバックをそのまま実行
- テストで実際のトランザクション不要な場合に使用

## 使用パターン

### ユースケース層での使用

複数のリポジトリ操作をトランザクションで実行。

**基本パターン:**

1. コンストラクタで `UnitOfWorkRunner` を注入
2. `run()` メソッドでトランザクション開始
3. コールバック内で複数のリポジトリ操作
4. すべて成功すれば自動コミット
5. 1つでも失敗すればロールバック

**使用例:**

```
ユーザー削除ユースケース:
1. unitOfWorkRunner.run() でトランザクション開始
2. コールバック内でuserRepository.remove()を呼び出し
3. コールバック内でauthClient.deleteUser()を呼び出し
4. 両方成功すればコミット、失敗すればロールバック
```

**注意点:**

- コールバック内ではリポジトリにUnit of Workを渡す
- コールバック外で例外が発生してもトランザクションは影響を受けない
- コールバックの戻り値は `run()` から返される

### リポジトリ層での対応

Unit of Workに対応したリポジトリ実装。

**実装パターン:**

1. コンストラクタで `uow?: UnitOfWork` をオプショナルで受け取る
2. 保存・削除メソッドで `uow` の有無をチェック
3. `uow` があればトランザクション操作を登録（即座に実行しない）
4. `uow` がなければ即座に実行

**注意点:**

- 検索系メソッド（find, list）はトランザクション不要
- 書き込み操作（save, remove）のみトランザクション対応
- 具体的な操作の登録方法は `../../../infrastructure/repository/README.md` を参照

### ハンドラ層での使用

通常、ハンドラ層では Unit of Work を直接使用しない。ユースケースに委譲。

## トランザクション制約

### 永続化技術固有の制約

永続化技術によってトランザクションに制約があります。

**一般的な制約:**

- 最大操作件数の制限
- トランザクションサイズの制限
- 同一リソースへの複数操作制約
- タイムアウト

**対応方法:**

- 制約を超える場合はトランザクションを分割
- 大きなデータは分割して処理
- 必要最小限の操作のみをトランザクションに含める

**詳細:**

- 具体的な制約値は `../../../infrastructure/unit-of-work/README.md` を参照

### エラーハンドリング

**トランザクション失敗の原因:**

- 整合性制約違反（条件式エラー等）
- リソース制限超過
- ネットワークエラー
- タイムアウト

**ロールバック:**

- トランザクション失敗時は自動ロールバック
- アプリケーション側でリトライ判断
- べき等性を考慮した設計

## DI設定

### サービスID

Unit of Work Runnerは通常DIコンテナに登録しない。ユースケース内で動的に生成。

**理由:**

- トランザクションごとに新しいインスタンスが必要
- ステートフルなため Singleton に適さない
- ユースケースで必要に応じて生成

### リポジトリへの注入

リポジトリコンストラクタで `uow?: UnitOfWork` を受け取る。

**DIコンテナ登録:**

- `uow` パラメータは通常 `undefined`
- Unit of Work Runnerがコールバック内で動的に注入

## テスト戦略

### スモールテスト

`UnitOfWorkRunnerDummy` を使用。

**テストパターン:**

- トランザクションロジックをテスト
- コールバックの実行順序を検証
- エラーハンドリングを確認
- 実際のコミット/ロールバックは実行しない

### ミディアムテスト

実際の永続化技術でトランザクションをテスト。

**テストパターン:**

- 複数操作のアトミック性を検証
- コミット成功時のデータ永続化を確認
- ロールバック時のデータ不変性を確認
- トランザクション制約を検証

**セットアップ:**

- テスト用データベース環境を使用
- テスト用データを準備
- トランザクション操作を実行して検証
- 詳細は `../../../infrastructure/unit-of-work/README.md` を参照

## 設計判断の理由

### なぜUnit of Workパターンを使うのか

1. **データ整合性**: 複数操作をアトミックに実行
2. **ACID保証**: トランザクションの4つの特性を実現
3. **抽象化**: データベース技術の詳細を隠蔽
4. **テスト容易性**: トランザクションロジックを分離してテスト

### なぜインターフェースで抽象化するのか

1. **ドメイン層の純粋性**: データベースSDKへの直接依存を避ける
2. **実装の切り替え**: DynamoDB以外のDBへの移行が容易
3. **依存関係の方向**: ドメイン層 ← インフラ層（依存性逆転の原則）
4. **テスト容易性**: Dummy実装で簡単にテスト

### なぜ自動コミット/ロールバックを実装するのか

1. **コードの簡潔性**: 明示的なcommit/rollback呼び出し不要
2. **エラーハンドリングの統一**: try-catchパターンで一貫した処理
3. **トランザクション漏れ防止**: コミット忘れを防ぐ
4. **リソース管理**: トランザクション開始・終了を確実に実行

### なぜリポジトリでUnit of Workをオプショナルにするのか

1. **柔軟性**: トランザクション不要な操作もサポート
2. **後方互換性**: 既存コードへの影響を最小化
3. **パフォーマンス**: 単一操作では即座に実行
4. **段階的導入**: 必要な箇所から順次トランザクション対応

## 実装時のチェックリスト

Unit of Work対応を追加する際の確認事項：

- [ ] リポジトリコンストラクタに `uow?: UnitOfWork` を追加
- [ ] 保存・削除メソッドで `uow` の有無をチェック
- [ ] `uow` がある場合は操作を登録（即実行しない）
- [ ] `uow` がない場合は即実行
- [ ] ユースケースで `UnitOfWorkRunner` を注入
- [ ] `run()` メソッドでトランザクション境界を管理
- [ ] コールバック内でリポジトリに `uow` を渡す
- [ ] エラーハンドリングを適切に実装
- [ ] ミディアムテストでトランザクション検証
- [ ] トランザクション制約（最大件数）を確認

## パフォーマンス最適化

### バッチサイズの最適化

- 不要な操作を含めない（必要最小限の操作のみ）
- 大量データの一括処理は分割（永続化技術の制限に応じて）
- トランザクション粒度の適切な設計

### 整合性チェックの活用

- 楽観的ロックで競合を検出
- 条件式で整合性チェック
- 不要なトランザクション失敗を削減

### リトライ戦略

- 一時的エラーはリトライ
- 永続的エラーは即座に失敗
- エクスポネンシャルバックオフ

## 参考

- `../../README.md` - ドメイン層全体の設計原則
- `../../../use-case/README.md` - ユースケースでの使用方法
- `../../../infrastructure/unit-of-work/README.md` - インフラ層の実装詳細
- `../../../infrastructure/repository/README.md` - リポジトリでの対応方法
- [Unit of Work パターン](https://martinfowler.com/eaaCatalog/unitOfWork.html)
