# Logger - 構造化ロギングインターフェース

ログ出力を抽象化するインターフェース。ドメイン層の純粋性を保ちながらログ機能を提供。

## 責務

- 構造化ログの出力（JSON形式）
- ログレベルに応じた適切な出力
- コンテキスト情報の付与（appendKeys）
- エラー情報の構造化

## ファイル構成

```
logger/
├── index.ts          # Loggerインターフェース定義
└── dummy.ts          # テスト用Dummy実装
```

## インターフェース定義

### AdditionalData

ログに付与する追加情報。

**型定義:**

- `Error` - エラーオブジェクト
- `{ [key: string]: unknown }` - 任意のキーバリューペア

### Loggerインターフェース

構造化ログ出力を抽象化するメソッド群。

**ログレベル:**

1. **debug**: プログラム内で起こっていることに関連するあらゆる情報

   - デバッグメッセージ
   - 開発中の詳細トレース
   - 本番環境では通常無効

2. **info**: システム操作とアクション

   - ユーザーが開始したアクション
   - スケジュールされたタスクの実行
   - システムのスタートアップ/シャットダウン

3. **warn**: 将来的にエラーになる可能性の状態

   - ライブラリ廃止警告
   - 使用可能リソースの不足
   - パフォーマンス低下

4. **error**: すべてのエラー状態
   - 例外発生
   - ビジネスロジックエラー
   - 外部サービスエラー

**メソッド:**

- `debug(message: string, data?: AdditionalData): void`
- `info(message: string, data?: AdditionalData): void`
- `warn(message: string, data?: AdditionalData): void`
- `error(message: string, data?: AdditionalData): void`
- `appendKeys(params: { [key: string]: unknown }): void`

### appendKeysメソッド

ログ出力に共通のキーを追加。

**用途:**

- リクエストID、ユーザーIDなどのコンテキスト情報を全ログに付与
- 一度設定すれば以降のログに自動的に含まれる
- トレーサビリティの向上

**パターン:**

```
1. ハンドラ層でappendKeys({ requestId, userId })を呼び出し
2. 以降のログに自動的にrequestIdとuserIdが含まれる
3. ログ分析時にリクエスト単位で追跡可能
```

## 実装

### インフラ層での実装

実装は `infrastructure/logger/index.ts` に配置。

**AWS Powertools実装の例:**

- `@aws-lambda-powertools/logger` を使用
- JSON形式で構造化ログ出力
- AWS CloudWatch Logsに対応
- ログレベルを環境変数で制御
- DIコンテナでシングルトン登録

### テスト用Dummy実装

`dummy.ts` でモック実装を提供。スモールテストで使用。

**特徴:**

- 全メソッドが空実装（何もしない）
- テストでログ出力を抑制
- ログ出力に依存せずビジネスロジックをテスト

## 使用パターン

### ドメイン層での使用

エンティティやValue Objectではロギング不要（純粋な値オブジェクト）。

### ユースケース層での使用

ビジネスロジックの実行状況をログ記録：

**パターン:**

1. コンストラクタでLoggerを注入
2. ユースケース開始時に `info()` で操作を記録
3. エラー発生時に `error()` で詳細を記録
4. 警告が必要な場合は `warn()` を使用

**ログレベル選択:**

- 正常系: `info()`
- 異常系: `error()`
- 警告: `warn()`
- デバッグ: `debug()`（開発中のみ）

### ハンドラ層での使用

リクエスト処理の開始・終了をログ記録：

**パターン:**

1. リクエスト開始時に `appendKeys()` でコンテキスト設定
2. バリデーションエラーは `warn()`
3. システムエラーは `error()`
4. 正常終了は `info()`

### インフラ層での使用

外部サービスとの通信をログ記録：

**パターン:**

1. DynamoDB操作の開始・終了
2. AWS SDKエラーの詳細記録
3. パフォーマンスメトリクス（処理時間等）

## DI設定

### 必要な登録

1. **Logger実装**: `LoggerImpl`（AWS Powertools使用）
2. **設定**: ログレベル（環境変数から取得）

### サービスID

- `LOGGER` - Logger実装
- `LOG_LEVEL` - ログレベル（DEBUG/INFO/WARN/ERROR）

## テスト戦略

### スモールテスト

`LoggerDummy`を使用してログ出力なしでテスト。

**テストケース例:**

- ビジネスロジックの検証（ログ出力は検証しない）
- エラーハンドリングの検証
- ログに依存しない純粋なロジックテスト

### ミディアムテスト

Logger実装のテストは通常不要。AWS Powertoolsの動作を信頼。

### 統合テスト（オプション）

実際のCloudWatch Logsへの出力テスト。必要に応じて実施。

## 設計判断の理由

### なぜインターフェースで抽象化するのか

1. **ドメイン層の純粋性**: ログライブラリへの直接依存を避ける
2. **テスト容易性**: Dummy実装で簡単にテスト
3. **実装の切り替え**: Powertools以外のロガーへの移行が容易
4. **依存関係の方向**: ドメイン層 ← インフラ層（依存性逆転の原則）

### なぜappendKeysが必要なのか

- リクエスト単位でログを追跡
- 共通情報を毎回渡す手間を省く
- ログ分析の効率化（requestIdでフィルタリング）

### なぜログレベルを分けるのか

- 本番環境でのログ量制御
- 問題発生時の原因特定の効率化
- 運用コストの最適化（不要なログを出さない）

## 参考

- `../../README.md` - ドメイン層全体の設計原則
- `../../../use-case/README.md` - ユースケースでの使用方法
- `../../../handler/README.md` - ハンドラでの使用方法
- `../../../infrastructure/logger/` - AWS Powertools実装
