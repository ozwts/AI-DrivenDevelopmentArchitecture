# 進化の原則

## 最高原則

**持続的に進化できる状態を維持する。** 変化に適応し続けるために、理解可能性と変更容易性を確保する。

---

## 進化の本質

**システムは変化し続ける。変化を前提として設計する。**

要件は変わる。技術は進歩する。理解は深まる。この変化に適応できなければ、システムは陳腐化する。

**本質的な問い**: 今日の決定が、明日の進化を妨げないか？

---

## ユビキタス言語

**人間とAI、現在と未来の開発者が、同じ言葉で語る。**

共通の語彙がなければ、意図は伝わらない。意図が伝わらなければ、進化は断絶する。

| 対象     | 統一すべき語彙                         |
| -------- | -------------------------------------- |
| ドメイン | ビジネス概念、エンティティ名、操作名   |
| 技術     | アーキテクチャ用語、パターン名         |
| プロセス | 憲法、ポリシー、レビュー等の規約・実装 |

**本質**: ユビキタス言語は、コードとドキュメントと会話を一致させる。

---

## 技術選定

**実績ある技術を優先する。**

| 基準                 | 理由                         |
| -------------------- | ---------------------------- |
| 採用実績が豊富       | 問題と解決策が蓄積されている |
| コミュニティが活発   | 長期的な保守性が期待できる   |
| AIの学習データが豊富 | 高品質な支援を受けられる     |

**本質**: 枯れた技術は、進化の土台となる。

---

## 必要最小限の実装

**現在のユースケースに必要なものだけを実装する。**

コードが増えれば増えるほど、変更のコストが高くなる。

- 「念のため」「将来使うかも」は実装しない
- 新しいユースケースが追加されたら、インターフェースを見直す

**本質**: コード量は変更コストに比例する。

---

## 継続的改善

**進化は一度の設計ではなく、継続的なリファクタリングで実現する。**

- 完璧な設計を目指さず、現時点で最適な設計を選ぶ
- 新しい要件が出たら、設計を見直す機会とする
- 技術的負債は早期に返済する
- 非効率を検出したら即座にリファクタリングする

**本質**: 進化を止めないために、常に変更可能な状態を保つ。

---

## collaborationとの関係

| 原則              | 焦点           | 時間軸 |
| ----------------- | -------------- | ------ |
| **collaboration** | どう協調するか | 今     |
| **evolution**     | どう持続するか | 未来   |

協調が今の成果を生み、進化がその成果を持続させる（`./collaboration-principles.md`参照）。
