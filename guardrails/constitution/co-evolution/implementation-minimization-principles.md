# 実装の必要最小限化の原則

## 最高原則

インターフェースは**必要性が明確になった時点で実装し、継続的にリファクタリング**しなければならない。目先の修正で終わらせず、都度都度インターフェースを見直し、最適な設計に進化させる。

## 理念

AI駆動開発において、AIは「念のため」の実装や「将来使うかも」という推測に基づく実装を提案しがちである。これは一見親切に見えるが、実際には保守コストを増大させ、インターフェースの肥大化を招く。また、非効率な実装（findByIdのループ等）をそのままにすると、パフォーマンス問題の温床となる。

真に価値のある開発とは、**今必要な機能を最適な形で実装し、必要性が生じた時点で適切にリファクタリングする**ことである。これにより、シンプルで保守性の高いコードベースを維持できる。

## 実現メカニズム：継続的リファクタリング

### 1. 使っていないインターフェースは実装しない

**現在のユースケースで使用されていないメソッドは実装しない。**

- 不要なメソッド（findAll、count、exists等）を「念のため」実装しない
- 既存メソッドで代替可能なメソッドは新規実装不要
- 現在必要なメソッドのみを実装する

**具体例**: 各ポリシー参照

- Repository: `policy/server/domain-model/30-repository-overview.md`
- UseCase: `policy/server/use-case/10-use-case-overview.md`
- Handler: `policy/server/handler/10-handler-overview.md`

### 2. 非効率な実装を検出したら即座にリファクタリング

**非効率な実装を見つけたら、目先の修正で終わらせず、インターフェースに遡ってリファクタリングする。**

- findByIdのループを見つけたら、findByIdsを実装
- N+1問題を見つけたら、専用の一括取得メソッドを実装
- その場で止まらず、インターフェース定義から修正

**具体例**: 各ポリシー参照

- Repository: `policy/server/domain-model/30-repository-overview.md`
- UseCase: `policy/server/use-case/10-use-case-overview.md`

### 3. 都度都度インターフェースを見直す

**新しいユースケースが追加されるたびに、既存インターフェースが最適かを検証する。**

- 初期実装は最小限のメソッドのみ
- ユースケース追加時に必要なメソッドを段階的に追加
- 非効率なパターンを見つけたら即座に最適化

**段階的インターフェース進化**:

1. 初期: 基本的なメソッド（findById等）のみ
2. 追加1: 複数取得が必要になったら一括取得メソッド（findByIds等）を追加
3. 追加2: 特定条件での検索が必要になったら専用メソッド（findByProjectId等）を追加

**具体例**: 各ポリシー参照

- Repository: `policy/server/domain-model/30-repository-overview.md`

### 4. 既存メソッドで代替可能なら新規実装不要

**既存メソッドの組み合わせで実現できる場合、新規メソッドは実装しない。**

- exists()はfindById()で代替可能
- 単純なヘルパーメソッドは既存メソッドの組み合わせで実現
- 本当に必要なメソッドのみを実装

**具体例**: 各ポリシー参照

- Repository: `policy/server/domain-model/30-repository-overview.md`

## ベネフィット

継続的リファクタリングにより、以下が実現される：

1. **シンプルで保守性の高いコードベース**: 使われていないメソッドがなく、インターフェースが肥大化しない
2. **パフォーマンス最適化**: findByIdのループではなく専用メソッド（findByIds）により、N+1問題を回避
3. **技術的負債の蓄積防止**: 目先の修正で終わらせず、都度都度リファクタリングすることで、非効率な実装が蓄積しない
4. **変更容易性の向上**: 必要なメソッドのみが存在するため、インターフェース変更時の影響範囲が小さい
5. **AI駆動開発との相性向上**: AIに「念のため」の実装を提案させず、明確な必要性に基づく実装のみを求める

## 実装判断基準

```
新しいメソッドの実装要求
    ↓
現在のユースケースで必要か？
    ↓ NO → 実装しない
    ↓ YES
既存メソッドで代替可能か？
    ↓ YES → 新規実装不要（既存メソッドを使用）
    ↓ NO
パフォーマンス問題があるか？（例: findByIdのループ）
    ↓ YES → 専用メソッドを実装（findByIds等）
    ↓ NO → シンプルな実装
```

## チェックリスト

```
[ ] 使われていないメソッドは実装していない
[ ] findByIdをループで使用していない（findByIdsを実装済み）
[ ] 新しいユースケース追加時にインターフェースを見直した
[ ] 既存メソッドで代替可能なメソッドは実装していない
[ ] 非効率な実装を見つけたら目先の修正で終わらせず、インターフェースをリファクタした
[ ] 「念のため」「将来使うかも」の実装をしていない
```

## まとめ

1. 使っていないインターフェースは実装しない（現在のユースケースで必要なメソッドのみ）
2. 非効率な実装を見つけたら即座にリファクタリング（findByIdのループ → findByIds実装、目先の修正で終わらせない）
3. 都度都度インターフェースを見直す（新しいユースケース追加時に既存インターフェースを検証し、継続的に最適な設計に進化）
4. 既存メソッドで代替可能なら新規実装不要（exists()はfindById()で代替可能）
