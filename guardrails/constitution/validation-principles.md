# バリデーション原則

## 最高原則

バリデーションはMECE（Mutually Exclusive and Collectively Exhaustive、相互排他的かつ網羅的）に実施する。

- **Mutually Exclusive（相互排他的）**: 同じバリデーションを複数箇所で重複して行わない
- **Collectively Exhaustive（網羅的）**: すべての入力に対して適切な検証を行う

## 理念

### なぜMECEか

**重複の問題**:

- 重複したバリデーションはメンテナンスコストを増大させる
- ルール変更時に複数箇所の修正が必要となり、整合性が失われるリスクがある
- どこで何が検証されるかが不明瞭になり、開発者が混乱する

**漏れの問題**:

- 検証漏れはシステムの脆弱性につながる
- 不正なデータがシステムに侵入し、予期しない動作を引き起こす
- セキュリティリスク、データ整合性の破綻を招く

**責務の明確化**:

- 各層が明確な責務を持つことで、変更の影響範囲を限定できる
- テストが容易になり、品質を担保しやすくなる

### MECEによって得られる価値

**保守性（Maintainability）**:

- バリデーションルールの変更が一箇所で完結する
- ルールの追加・変更・削除が容易で、影響範囲が明確
- チーム全体で一貫したバリデーション戦略を共有できる

**信頼性（Reliability）**:

- すべての入力が適切に検証され、不正なデータがシステムに入らない
- 各層の責務が明確で、検証漏れを防止できる
- 多層防御ではなく、適切な層での適切な検証により、システムの安全性を担保

**理解性（Understandability）**:

- どこで何が検証されるかが明確で、開発者が迷わない
- 新規参加者がバリデーション戦略を理解しやすい
- コードレビュー時に責務の逸脱を容易に発見できる

**テスタビリティ（Testability）**:

- 各層のバリデーションを独立してテストできる
- モックやスタブを使った単体テストが容易
- テストの重複を排除し、効率的なテスト戦略を実現

## 制度：三権分立による実現

### Policy（立法）

各レイヤーのバリデーション責務を明文化する。

#### 責務の階層化

バリデーションを4つの階層に分類し、各階層の責務を定義：

1. **型レベルのバリデーション**: データの形式・長さ・型・必須性
2. **ドメインルール**: ドメイン固有の制約・形式（OpenAPIで表現できない複雑なルール）
3. **ビジネスルール**: 権限チェック・状態チェック・関連チェック
4. **構造的整合性**: エンティティの不変条件・集約ルールの保護

#### 単一の真実の情報源（Single Source of Truth）

型レベルのバリデーションは、APIスキーマ定義（OpenAPI等）に集約する。

**原則**:

- 各バリデーションルールは一箇所でのみ定義
- 自動生成により、フロントエンド・サーバー双方で同じルールを適用
- 手動でのルール重複実装を禁止

**利点**:

- ルール変更時の修正が一箇所で完結
- フロントエンド・サーバー間のバリデーション不整合を防止
- 仕様書（OpenAPI）とコードの乖離を防止

#### ポリシーの役割

各レイヤー・カテゴリごとに、具体的なバリデーション責務を定義：

- `policy/server/domain-model/` - サーバー側ドメインモデルのバリデーション責務
- `policy/server/handler/` - サーバー側入力バリデーション責務
- `policy/web/component/` - フロントエンド側フォームバリデーション責務

### Procedure（行政）

バリデーションを実装・実行する。

#### 実行の流れ

```
外部入力
  ↓
入口での検証（型レベル）
  ↓ OK
ドメイン検証（ドメインルール）
  ↓ OK
ビジネス検証（ビジネスルール）
  ↓ OK
データ永続化
```

**各段階の役割**:

1. **入口での検証**: クライアント入力を型レベルで検証（フォーム、APIハンドラー）
   - すべての外部境界で必須
   - スキーマ定義から自動生成された検証コードを使用
2. **ドメイン検証**: ドメイン固有ルールを適用
   - OpenAPIで表現できない複雑なルールのみ
   - Value Objectパターンで実装
3. **ビジネス検証**: データベース参照を伴うビジネスルールを適用
   - UseCaseレイヤーで実装
   - 権限・状態・関連チェック等
4. **構造保証**: エンティティの不変条件を保護
   - Entityレイヤーで実装（最小限）
   - 基本的にはバリデーションを実施しない

#### 自動化の原則

手動実装を最小限に抑え、自動生成を活用する。

**自動生成すべきもの**:

- 型レベルのバリデーションコード（OpenAPI → Zod等）
- API型定義（OpenAPI → TypeScript型）

**手動実装すべきもの**:

- OpenAPIで表現できない複雑なドメインルール
- データベース参照を伴うビジネスルール

#### レイヤー間の信頼

**上位レイヤーの検証は下位レイヤーで重複しない**:

- ハンドラーで検証済みの型制約を、ドメイン層・ユースケース層で再度検証しない
- 下位レイヤーは上位レイヤーの検証が完了していることを前提とする

**検証の連鎖**:

- 各層は自身の責務に応じたバリデーションのみを実施
- 上位層の検証結果を信頼し、重複検証を避ける

### Review（司法）

実装がMECE原則に準拠しているかを審査する。

#### 審査項目

**MECE準拠の確認**:

- 型レベルのバリデーションがスキーマ定義に記述されているか
- 同じバリデーションが複数箇所で重複していないか
- すべての入力経路で適切な検証が行われているか（網羅性）
- 各層の責務を超えたバリデーションが実装されていないか（相互排他性）

**違反パターンの検出**:

- 手動でのバリデーション重複（OpenAPIで定義可能なのに手動実装）
- スキーマ定義の欠落（型制約が定義されていない）
- 責務の逸脱（例: エンティティでのビジネスルール検証、UseCaseでの型チェック）
- 検証漏れ（外部入力経路での検証欠如）

#### レビューの実施

**自動レビュー（MCP）**:

- コード変更時に自動的にMCPツールが実行
- MECE原則に準拠しているかをAIが審査
- 違反箇所を指摘し、修正案を提示

**手動レビュー**:

- コードレビュー時に責務の逸脱をチェック
- 新規API追加時のバリデーション戦略確認

## 原則の適用

### 検証の網羅性

すべての入力経路で、適切なレベルの検証を実施する。

**外部境界での検証必須**:

- ユーザー入力（フォーム）
- API入力（ハンドラー）
- 外部システムからの入力

**内部境界での検証**:

- 基本的に不要（上位層で検証済みのため）
- 例外: ドメイン固有ルール、ビジネスルール

### レイヤー別の責務

各レイヤーは自身の責務に応じたバリデーションのみを実施する。

**型レベル → ドメインルール → ビジネスルール → 構造的整合性**:

- 上流から下流へとバリデーションが流れる
- 下流レイヤーは上流の検証完了を前提とする
- 各レイヤーで重複しない
