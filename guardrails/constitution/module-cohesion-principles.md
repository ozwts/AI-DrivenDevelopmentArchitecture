# モジュール凝集の原則

## 最高原則

モジュールは**機能的凝集（Functional Cohesion）**に基づき構成しなければならない。「カテゴリが同じ」ではなく「目的が同じ」要素を一つの場所にまとめ、変更の影響範囲を構造的に限定する。

## 理念

### 機能的凝集の本質

機能的凝集とは、モジュール内のすべての要素が**単一の明確な目的**のために連携している状態である。

コロケーションとは、関連するコードを**物理的に近くに配置する**ことで、変更の影響範囲を明確化し、コードの理解と修正を容易にする設計原則である。

### 論理的凝集（The Anti-Pattern）を避ける

**定義**: 関連性の低い要素が「カテゴリが同じ」という理由だけで一つのモジュールにまとめられた状態。

**問題点**:
- 条件分岐がコード全体に散らばる
- 一つの変更が予期せぬ箇所に影響する（副作用）
- 要件とコードの対応関係が不明瞭になる
- 「UIがほぼ同じ」という初期判断が、後に技術的負債となる

### 得られるベネフィット

**変更への強さ（Resilience to Change）**:
- ある機能の修正が他の機能に影響しない
- 機能の削除がディレクトリの削除で完結する
- 影響範囲がディレクトリ構造から構造的に保証される

**要件との明確な対応（Clear Requirement Mapping）**:
- 機能単位で書かれた要件定義書とコードが1:1で対応する
- 新しいメンバーが機能単位でコードを理解しやすい

**AIの自律開発速度の最大化**:
- ディレクトリ = 機能境界により、AIが影響範囲を正確に把握できる
- 並行開発時のコンフリクトを構造的に回避

## 核心原則

### 原則1: ディレクトリ = 機能境界

ディレクトリ構造を機能境界として活用する。関連ファイルはすべて同じディレクトリに配置し、データフローがディレクトリ内で完結するようにする。

### 原則2: ロール・コンテキストによる構造的分離

異なるユーザーロールやコンテキストは、UIが似ていても**条件分岐ではなくディレクトリ構造で分離**する。

### 原則3: 責務が異なれば分離する

見た目が同じでも、責務（作成・編集・参照等）が異なる場合はモジュールを分割する。

### 原則4: 共通化の判断基準

「似ている」と感じても、すぐに共通化しない。共通化してよいのは、**意味的に同一**の場合のみ。

**いつ（WHEN）**: 3つ以上の箇所で利用されるまで共通化を待つ

**何を（WHAT）**: 意味的に同一のもののみ共通化する

**どこに（WHERE）**: 最も近い共通の親に配置する

### 原則5: 分割できない場合の機能的凝集

単一モジュール内で多様な要素を扱う場合は、パターンマッチ等で各ケースの処理を分離し、網羅性を保証する。

## 関連する原則との関係

**アーキテクチャ原則との関係**:
- アーキテクチャ原則が「システム全体の構造」（レイヤー分離、型契約）を定義
- モジュール凝集の原則が「モジュール内部の構造」を定義
- 相互排他的: マクロ視点（システム全体）とミクロ視点（モジュール内部）

**分散協調開発原則との関係**:
- 分散協調開発原則が「複数AIの並行作業」のためのタスク分割を定義
- モジュール凝集の原則が「コンフリクト回避」のためのコード配置を定義
- 相互補完的: 適切なコロケーションが分散協調開発の独立性を実現

**単純性の原則との関係**:
- 単純性の原則が「Simple vs Easy」の判断基準を定義
- モジュール凝集の原則が「凝集の具体的パターン」を定義
- 相互補完的: Simpleを選ぶ判断力が適切な凝集を実現

## まとめ

1. **機能的凝集**: モジュール内のすべての要素が「単一の明確な目的」のために連携する
2. **ディレクトリ = 機能境界**: 関連ファイルを同じディレクトリに配置し、データフローを閉じる
3. **構造的分離**: 条件分岐ではなく、ディレクトリ構造でロール・責務を分離する
4. **慎重な共通化**: 「3回ルール」を適用し、早すぎる抽象化を避ける
