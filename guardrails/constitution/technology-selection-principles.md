# 技術選定の原則

## 最高原則

技術は**実績と支援が豊富な技術を選択し、ビジネスロジックを明示的に記述し、運用負荷とコストを最適化**しなければならない。

## 理念

AI駆動開発において、技術選定は長期的な保守性とビジネス価値の実現に直結する。実績のある技術を選択することで、ドキュメント・コミュニティ・AI支援の恩恵を最大化できる。ビジネスロジックを明示的に記述することで、変更容易性と理解容易性を確保する。運用負荷とコストを最適化することで、持続可能な開発を実現する。

**避けるべきアンチパターン**:
- ニッチな技術・独自技術への過度な依存（支援・ドキュメント不足）
- インフラ層へのビジネスロジックの分散（追跡困難、変更困難）
- 過度な抽象化・複雑化（保守性低下、理解困難）

## 3つの柱

### 第1の柱：実績と支援が豊富な技術を優先

**原則**: 技術選定時は、実績があり、支援が豊富な技術を優先する。

**理由**:
- **豊富なドキュメント**: 公式ドキュメント、学習リソースが充実
- **強力なコミュニティ**: 問題解決のための情報が豊富
- **AI支援の恩恵**: LLMの学習データが豊富で、高品質な支援が得られる
- **人材確保**: エンジニアの採用・育成が容易
- **長期的保守性**: 技術の存続可能性が高い

**判断基準**:
- 採用実績が豊富（大規模プロジェクト、大手企業等）
- 活発なコミュニティとメンテナンス
- 学習リソースが充実（公式ドキュメント、書籍、記事）
- LLMが効果的に支援できる（学習データが豊富）
- エコシステムが成熟している

**例外的に新しい技術を選ぶ場合の条件**:
- 既存技術で解決できない明確な課題がある
- ビジネス上の競争優位性に直結する
- 技術的負債のリスクを理解し、受け入れる覚悟がある

### 第2の柱：ビジネスロジックを明示的に記述

**原則**: ビジネスロジックは、インフラ層の設定や連携ではなく、明示的なコードとして実装する。

**理由**:
- **変更容易性**: ビジネスルール変更時にコード修正のみで対応可能
- **理解容易性**: ロジックが一箇所に集約され、読んで理解できる
- **追跡可能性**: ロジックがコードとして明示的に存在し、静的解析・検索可能
- **テスタビリティ**: ユニットテスト・統合テストが容易
- **ベンダーロックイン回避**: 特定インフラへの依存を最小化
- **AI支援の恩恵**: コードとして記述されたロジックはLLMが理解・修正可能

**実装方針**:
- **ドメインロジックはコードで実装**: ビジネスルールをプログラミング言語で明示的に記述
- **インフラは薄く、ロジックは厚く**: インフラ層はデータ永続化・認証等のサポート機能のみ
- **設定より実装**: 設定ファイルや宣言的記述でロジックを表現せず、コードで実装
- **分散を避ける**: ビジネスロジックを複数のインフラコンポーネント間に分散させない

**判断基準**:
- ビジネスルールがコードとして読める
- ロジックの変更がコード修正のみで完結する
- インフラ層の設定変更でビジネスロジックが変わらない
- 静的解析でロジックの影響範囲を追跡できる

### 第3の柱：運用負荷とコストを最適化

**原則**: 運用負荷を最小化し、コスト効率を重視した技術を選択する。

**理由**:
- **持続可能性**: 少人数チームでも運用可能
- **開発速度**: インフラ管理に時間を取られず、ビジネスロジックに集中
- **スケーラビリティ**: 負荷変動に自動対応
- **コスト効率**: 必要な分だけリソースを使用

**実装方針**:
- **マネージドサービス優先**: サーバー管理、パッチ適用、スケーリング設定が不要
- **自動化を重視**: 手動オペレーションを最小化
- **シンプルな構成**: 複雑なインフラ構成を避ける
- **不要なリソースを作らない**: 使われていない機能・サービスは実装しない

**判断基準**:
- 運用タスクが最小化されている（自動化されている）
- スケーリングが自動的に行われる
- 障害時の復旧が自動化されている
- コストが使用量に応じて変動する（固定費が少ない）

## 技術選定判断基準

```
技術選定の要求
    ↓
実績と支援が豊富な技術か？
    ↓ NO → 代替技術を検討、または例外条件を満たすか確認
    ↓ YES
ビジネスロジックを明示的に記述できるか？
    ↓ NO → インフラ依存が高すぎる、再検討
    ↓ YES
運用負荷とコストが最適化されているか？
    ↓ NO → 運用負荷・コストの高い技術は避ける、マネージドサービスを検討
    ↓ YES
    → 採用
```

## ベネフィット

3つの柱に従うことで、以下が実現される：

1. **AI駆動開発との相性**: 実績ある技術 + コードベースのロジック = LLMの高品質な支援
2. **長期的保守性**: 豊富なドキュメントとコミュニティサポート
3. **変更容易性**: ビジネスロジックがコードに集約され、修正が容易
4. **追跡可能性**: ロジックの影響範囲を静的に追跡可能
5. **持続可能性**: 運用負荷最小化により、少人数チームでも運用可能
6. **コスト効率**: 不要なリソースを排除し、必要な分のみ使用

## チェックリスト

```
[ ] 実績のある技術を選択している（採用事例、コミュニティ、ドキュメントが豊富）
[ ] LLMが効果的に支援できる技術である
[ ] ビジネスロジックがコードで明示的に記述されている
[ ] インフラ層の設定・連携にビジネスロジックが分散していない
[ ] マネージドサービスを優先している
[ ] 運用負荷を最小化している（自動化、自動スケーリング）
[ ] コスト効率を考慮している（不要なリソースなし、使用量に応じた課金）
[ ] ニッチな技術・独自技術を避けている（または正当な理由がある）
```

## まとめ

技術選定の3原則：

1. **実績と支援が豊富な技術を優先**: ドキュメント、コミュニティ、AI支援の恩恵を最大化
2. **ビジネスロジックを明示的に記述**: インフラ層への分散を避け、コードとして明示的に実装
3. **運用負荷とコストを最適化**: マネージドサービス優先、自動化重視、シンプルな構成

これにより、AI駆動開発との相性、長期的保守性、変更容易性、追跡可能性、持続可能性、コスト効率を同時に達成する。

**具体例**: 各ポリシーファイル参照
- インフラ層: `policy/server/infrastructure/` (今後作成予定)
- 技術スタック: プロジェクト固有のドキュメント
