# 単純性の原則（Simplicity Principles）

## 最高原則

設計は**Simple（単純）を優先し、Easy（容易）に惑わされてはならない**。Simpleとは構造的に「絡んでいない」客観的状態であり、Easyとは人間の主観的な「慣れ」や「近さ」である。この区別を常に意識し、長期的な変更容易性を確保する。

## 理念

### Simple vs Easy の本質的区別

| 概念 | 定義 | 性質 | 例 |
|------|------|------|-----|
| **Simple** | 構造的に絡んでいない | 客観的・測定可能 | 単一責務、一方向依存、明確な境界 |
| **Easy** | 人間にとって近い・慣れている | 主観的・相対的 | 使い慣れたライブラリ、コピペ実装 |

**核心**: Simpleは構造の性質、Easyは人間の認知の性質。この二つを混同することが複雑性の主因である。

### Entanglement（絡み合い）の危険性

複雑性の正体は「機能の多さ」ではなく「要素間の絡み合い」である。

**絡み合いの特徴**:
- 責務の混在（一つのモジュールが複数の理由で変更される）
- 密結合（一方の変更が他方を壊す）
- 循環依存（A→B→C→A）
- 暗黙の依存（コードに現れない依存関係）

**絡み合いの増殖**: 最初は小さな絡みでも、気づく頃には解けなくなる。指数関数的に複雑性が増大する。

### AI時代における価値転換

AIがEasyを無限拡張する時代において、「Simpleを選ぶ能力」が人間にしかできない領域として価値を増す。

**AIの傾向**:
- 「関連しそうなもの」を結合する
- 局所的に「賢い」抽象化を生成する
- 短期的な便利さを優先する

**人間の責務**:
- 構造設計（責務分離、境界設定、依存方向）を先に決める
- Simpleの基準をAIに明示する
- 絡み合いの発生を監視する

## 核心原則

### 原則1: Simple First, Then Easy

構造を先に決め、その後にEasyを乗せる。

**正しい順序**:
1. 責務を分離する
2. 境界を設定する
3. 依存方向を整理する
4. その上でEasyなツール・フレームワークを適用

**誤った順序**:
1. Easyなツールを選ぶ
2. ツールの制約に合わせて設計する
3. 構造的な問題が蓄積する

### 原則2: 変更影響範囲の即答可能性

「このコードを変更したら、どこに影響するか？」に即答できなければ、それは絡んでいる。

**即答できる状態**:
- ディレクトリ構造から影響範囲が明確
- 依存が一方向で追跡可能
- 境界が明確で越境していない

**即答できない状態**:
- 「たぶんここも影響する」という曖昧さ
- 変更のたびに全体を確認する必要
- 予期しない副作用が頻発

### 原則3: 抽象化の必要性検証

「この抽象化がなくても動くか？」を常に問う。

**必要な抽象化**:
- 重複を排除し、変更を一箇所に集約
- 境界を明確にし、責務を分離
- テスト容易性を向上

**不要な抽象化**:
- 「将来使うかも」の推測
- 「賢く見える」が構造を破壊
- 1箇所でしか使われない汎用化

### 原則4: 愚直さの価値

「賢さ」より「読みやすさ」を優先する。

**愚直でよいケース**:
- 3行の重複コードより、意図が明確な個別実装
- 「スマートな」ワンライナーより、ステップごとの処理
- 過度なDRYより、コンテキストに特化した実装

**賢さが必要なケース**:
- 3箇所以上の真の重複（意味的に同一）
- 明確なパターンの抽出
- 複雑性を隠蔽する必要がある境界

## 9つの問い（判断枠組み）

### Entanglement（絡み合い）の検出

1. **「この2つは本当に一緒にすべきか？」**
   - 別々に変更される可能性があるなら分離する
   - 「似ている」は分離の理由にならない

2. **「変更影響範囲を即答できるか？」**
   - 即答できなければ絡んでいる
   - ディレクトリ構造から読み取れるべき

3. **「片方を変えると他方が壊れるか？」**
   - 壊れるなら密結合している
   - インターフェースで分離すべき

### Easy の誘惑への警戒

4. **「慣れているだけではないか？」**
   - 慣れ ≠ Simple
   - 新しいメンバーにも理解しやすいか

5. **「1週間後の自分は理解できるか？」**
   - 「今わかる」は Easyの罠
   - 明示的で自己説明的なコードを

6. **「短期か長期か、どちらの速さを選んでいるか？」**
   - Easy: 短期的に速い → 長期的に遅い
   - Simple: 短期的に遅い → 長期的に速い

### Simple への立ち戻り

7. **「分割の目的を言語化できるか？」**
   - 言語化できない分割は不要
   - 「なんとなく」の分割は避ける

8. **「この抽象化がなくても動くか？」**
   - 動くなら不要な抽象化
   - 必要になった時点で導入

9. **「この『賢さ』は本当に必要か？」**
   - 賢さはコストを伴う
   - 愚直でも読めるコードを優先

## 関連する原則との関係

**アーキテクチャ原則との関係**:
- アーキテクチャ原則が「境界による並行開発」を定義
- 単純性の原則が「境界の判断基準」を提供
- 相互補完的: Simpleな境界が並行開発を実現

**モジュール凝集の原則との関係**:
- モジュール凝集の原則が「機能的凝集」を定義
- 単純性の原則が「凝集の判断基準」を提供
- 相互補完的: Simpleな凝集が変更容易性を実現

**実装の必要最小限化の原則との関係**:
- 必要最小限化の原則が「実装タイミング」を定義
- 単純性の原則が「実装の複雑さ」を制御
- 相互補完的: Simpleな実装が必要最小限を実現

## まとめ

1. **Simple ≠ Easy**: 構造的単純さと認知的容易さを区別する
2. **Simple First**: 構造を先に決め、Easyは後から乗せる
3. **Entanglement回避**: 絡み合いを検出し、分離する
4. **即答可能性**: 変更影響範囲を常に把握できる状態を維持
5. **愚直さの価値**: 「賢さ」より「読みやすさ」を優先
