# ポリシー構造の原則

## 最高原則

ポリシーは**段階的理解と機械的検証**を可能にする構造でなければならない。概要から詳細へ段階的に情報を提供し、AIエージェントと人間の両方が効率的に理解・適用できる形式とする。

## 階層構造の原則

### 原則1: X0-{topic}-overview.md（概要ファイル）

**必須セクション**:

1. **核心原則**: この領域の最も重要な原則を1-2文で表現
2. **責務**: 「実施すること/実施しないこと」を明示（MECE原則）
3. **Do/Don't**: 良い例・悪い例を具体的なコードで提示

**例**:

```markdown
## 実施すること

1. **データ永続化**: DBへの読み書き、トランザクション管理
2. **データ変換**: ドメインモデル ⇔ DB形式の変換

## 実施しないこと

1. **ビジネスルール** → UseCase層で実施
2. **バリデーション** → Domain層で実施

## Do / Don't

### ✅ Good

（具体的なコード例）

### ❌ Bad

（具体的なコード例と理由）
```

### 原則2: X1-X9-{topic}-{detail}.md（詳細ファイル）

**必須セクション**: 概要、関連ドキュメント、実装パターン、Do/Don't

### 原則3: ファイル番号体系と命名規則

**番号体系**:

```
10番台: 領域全体の概要と横断的原則
  - 10: 領域全体の概要
  - 11-19: 横断的詳細

20番台以降: トピック別（10番台刻み）
  - X0: トピック概要
  - X1-X9: トピック詳細
```

**命名規則**:

- 概要: `X0-{topic}-overview.md`（必ず`-overview`サフィックス）
- 詳細: `X1-{topic}-{detail}.md`（具体的な内容名）

## 内容粒度の原則

### 原則4: 核心原則は1-2文で表現

AIエージェントが本質を即座に把握できる必要がある。

### 原則5: 責務は「実施/非実施」で明確化（MECE原則）

非実施には必ず代替実施場所を明記する。

### 原則6: Do/Don'tは必ずコード例を含める

抽象的な説明よりも、具体的なコード例が理解を促進する。

## MECE原則

### 原則7: 責務分離（相互排他的かつ網羅的）

- **各層・コンポーネントの責務が重複せず、漏れがない**
- バリデーション階層: 型レベル、ドメインルール、ビジネスルールが重複しない
- ポリシーファイル間: 同じ内容が複数ファイルに記載されない

### 原則8: 責務外の内容は参照のみ

**原則**: 各ポリシーファイルは自身の責務のみを詳述し、責務外の内容は参照リンクにとどめる。

```markdown
// ✅ Good: 責務外は参照のみ

## バリデーション

**参照**: `11-domain-validation-strategy.md`

// ❌ Bad: 責務外の詳細を記載

## バリデーション

### 型レベルバリデーション

OpenAPIで定義した制約（minLength、maxLength...）

### ドメインルール

Value Objectで...
（詳細が続く）
```

**理由**:

- **Single Source of Truth**: 情報の唯一の情報源を維持
- **保守性**: 変更時に1箇所のみ修正
- **不整合防止**: 複数箇所での記載は不整合のもと

### 原則9: Single Source of Truth

すべての情報は唯一の情報源から派生する。

```
OpenAPI仕様（唯一の情報源） → Zodスキーマ → TypeScript型定義
```

**禁止**: 手動型定義作成、バリデーションルール重複、コメントによる型制約説明

## 禁止事項

### 原則10: チェックリストの禁止

**禁止**: ポリシーファイルにチェックリストを記載しない。

**理由**:

- **メンテナンスコスト**: チェックリストは本文と二重管理になり、不整合が発生しやすい
- **冗長性**: 本文で説明済みの内容をチェックリスト形式で繰り返すことになる
- **MECE原則違反**: 同じ情報が複数形式で存在することになる

**代替手段**:

- **静的解析**: ESLint/TypeScriptで機械的に検証
- **MCPツール**: guardrailsレビューツールで自動検証
- **Do/Don't**: 良い例・悪い例で判断基準を明示

```markdown
// ❌ Bad: チェックリスト

## チェックリスト

[ ] すべてのプロパティをreadonlyで定義
[ ] コンストラクタはPropsパターン
[ ] Result型を返すfrom()メソッド

// ✅ Good: Do/Don'tで表現

## Do / Don't

### ✅ Good

export class Todo {
readonly id: string; // readonlyで定義
constructor(props: TodoProps) { ... } // Propsパターン
}

### ❌ Bad

export class Todo {
id: string; // ❌ readonlyがない
constructor(id: string, title: string) { ... } // ❌ 個別引数
}
```

## 思想原則

### 原則11: Always Valid Domain Model

ドメインオブジェクトは作成時点から常に正しい状態である。不正な状態を許容しない。

### 原則12: 解析可能性の最大化

変更の影響範囲を静的に追跡可能にする。型システムで表現可能なことは型で表現する。

**参照**: `../co-evolution/analyzability-principles.md`

## ディレクトリ構造の原則

### 原則13: フラットなディレクトリ構造

ポリシーディレクトリはフラットに配置し、レビュー時の参照を容易にする。

```
policy/server/
├── domain-model/
├── use-case/
├── port/
├── logger/
├── fetch-now/
├── storage-client/
├── auth-client/
├── unit-of-work/
├── handler/
├── repository/
└── di-container/
```

### 原則14: meta.json によるメタ情報定義

各ポリシーディレクトリには `meta.json` を配置し、ラベル・説明・依存関係を定義する。

```json
{
  "label": "ユースケース",
  "description": "ビジネスロジックの実装、Result型パターン",
  "dependencies": ["domain-model", "port"]
}
```

**スキーマ**:

| フィールド     | 型       | 必須 | 説明                     |
| -------------- | -------- | ---- | ------------------------ |
| `label`        | string   | ○    | 選択肢の表示名           |
| `description`  | string   | ○    | 選択肢の説明文           |
| `dependencies` | string[] | -    | 関連するポリシーIDの配列 |

### 原則15: 依存関係の方向性

**一方向のみ**: 上位レイヤー → 下位レイヤー の方向で記述する。相互参照は禁止。

**portによる集約**: 個別ポート（logger, fetch-now等）への依存は `port` で集約する。

```json
// ✅ Good: portで集約
{ "dependencies": ["domain-model", "port"] }

// ❌ Bad: 個別ポートを列挙
{ "dependencies": ["domain-model", "logger", "fetch-now", "storage-client"] }
```

**個別ポートの所属表現**: 各ポートは `port` への依存で「portの一部」であることを示す。

```json
// logger/meta.json
{ "dependencies": ["port"] }
```
