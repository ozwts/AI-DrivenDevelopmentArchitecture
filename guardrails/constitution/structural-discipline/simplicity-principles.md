# 簡潔さの原則

## 最高原則

**Simpleを優先し、Easyに惑わされない。** 構造的な単純さを追求し、短期的な便利さに流されない。

---

## Simple vs Easy

| 概念 | 定義 | 性質 |
|------|------|------|
| **Simple** | 構造的に絡んでいない | 客観的・測定可能 |
| **Easy** | 慣れている・近い | 主観的・相対的 |

**本質的な違い**:
- Simpleは構造の性質（絡み合いの有無）
- Easyは人との関係（慣れ、近さ）

**危険な罠**:
- Easyなものは最初は速いが、後で複雑性として返ってくる
- Simpleなものは最初は遅いが、長期的に速度を維持できる

---

## 判断基準

### 絡み合いの検出

**「このコードを変更したら、どこに影響するか？」に即答できるか。**

- 即答できる → Simple
- 即答できない → 絡んでいる → 分離が必要

### 複雑性の兆候

- 変更が予期せぬ箇所に波及する
- 理解するために多くのファイルを読む必要がある
- 「なぜこうなっているか」を説明できない

---

## 9つの問い

### 絡み合いの検出
1. この2つは本当に一緒にすべきか？
2. 変更影響範囲を即答できるか？
3. 片方を変えると他方が壊れるか？

### Easyの誘惑への警戒
4. 慣れているだけではないか？
5. 1週間後の自分は理解できるか？
6. 短期か長期か、どちらの速さを選んでいるか？

### Simpleへの立ち戻り
7. 分割の目的を言語化できるか？
8. この抽象化がなくても動くか？
9. この「賢さ」は本当に必要か？

---

## 簡潔さの実践

### 愚直さの価値

- 「賢い」コードより「明快な」コードを選ぶ
- 抽象化は必要になるまで導入しない
- 最も単純な解決策をまず検討する

### 複雑性への抵抗

- 新しい概念の導入は慎重に
- 既存の仕組みで解決できないか先に検討
- 「将来必要になるかも」で複雑性を増やさない
- 重厚長大なフレームワークより、薄いライブラリを組み合わせる
